7
1
0
2

b

e

F

2
2

]

G

L

.

s

c

[

4
v
7
0
9
2
0

.

9
0
6
1

:

v

i

X

r

a

Published as a conference paper at ICLR 2017

S EM I -SU PERV I S ED C LA S S I FICAT ION W I TH
GRA PH CONVO LU T IONA L N E TWORK S

Thomas N. Kipf

University of Amsterdam

T.N.Kipf@uva.nl

Max Welling

University of Amsterdam
Canadian Institute for Advanced Research (CIFAR)

M.Welling@uva.nl

AB STRAC T

We present a scalable approach for semi-supervised learning on graph-structured
data that is based on an efﬁcient variant of convolutional neural networks which
operate directly on graphs. We motivate the choice of our convolutional archi-
tecture via a localized ﬁrst-order approximation of spectral graph convolutions.
Our model scales linearly in the number of graph edges and learns hidden layer
representations that encode both local graph structure and features of nodes. In
a number of experiments on citation networks and on a knowledge graph dataset
we demonstrate that our approach outperforms related methods by a signiﬁcant
margin.

1

IN TRODUC T ION

We consider the problem of classifying nodes (such as documents) in a graph (such as a citation
network), where labels are only available for a small subset of nodes. This problem can be framed
as graph-based semi-supervised learning, where label information is smoothed over the graph via
some form of explicit graph-based regularization (Zhu et al., 2003; Zhou et al., 2004; Belkin et al.,
2006; Weston et al., 2012), e.g. by using a graph Laplacian regularization term in the loss function:

(cid:88)

L = L0 + λLreg , with Lreg =

Aij (cid:107)f (Xi ) − f (Xj )(cid:107)2 = f (X )

(cid:62)

∆f (X ) .

(1)

i,j

Here, L0 denotes the supervised loss w.r.t. the labeled part of the graph, f (·) can be a neural network-
like differentiable function, λ is a weighing factor and X is a matrix of node feature vectors Xi .
a degree matrix Dii = (cid:80)
∆ = D − A denotes the unnormalized graph Laplacian of an undirected graph G = (V , E ) with
N nodes vi ∈ V , edges (vi , vj ) ∈ E , an adjacency matrix A ∈ RN ×N (binary or weighted) and
j Aij . The formulation of Eq. 1 relies on the assumption that connected
nodes in the graph are likely to share the same label. This assumption, however, might restrict
modeling capacity, as graph edges need not necessarily encode node similarity, but could contain
additional information.
In this work, we encode the graph structure directly using a neural network model f (X, A) and
train on a supervised target L0 for all nodes with labels, thereby avoiding explicit graph-based
regularization in the loss function. Conditioning f (·) on the adjacency matrix of the graph will
allow the model to distribute gradient information from the supervised loss L0 and will enable it to
learn representations of nodes both with and without labels.
Our contributions are two-fold. Firstly, we introduce a simple and well-behaved layer-wise prop-
agation rule for neural network models which operate directly on graphs and show how it can be
motivated from a ﬁrst-order approximation of spectral graph convolutions (Hammond et al., 2011).
Secondly, we demonstrate how this form of a graph-based neural network model can be used for
fast and scalable semi-supervised classiﬁcation of nodes in a graph. Experiments on a number of
datasets demonstrate that our model compares favorably both in classiﬁcation accuracy and efﬁ-
ciency (measured in wall-clock time) against state-of-the-art methods for semi-supervised learning.

1

 
 
 
 
 
 
Published as a conference paper at ICLR 2017

2 FA ST A P PROX IMATE CONVO LU T ION S ON GRA PH S

(cid:16)

In this section, we provide theoretical motivation for a speciﬁc graph-based neural network model
f (X, A) that we will use in the rest of this paper. We consider a multi-layer Graph Convolutional
Network (GCN) with the following layer-wise propagation rule:
(2)
IN is the identity matrix, ˜Dii = (cid:80)
Here, ˜A = A + IN is the adjacency matrix of the undirected graph G with added self-connections.
˜Aij and W (l) is a layer-speciﬁc trainable weight matrix. σ(·)
denotes an activation function, such as the ReLU(·) = max(0, ·). H (l) ∈ RN ×D is the matrix of ac-
tivations in the l th layer; H (0) = X . In the following, we show that the form of this propagation rule
can be motivated1 via a ﬁrst-order approximation of localized spectral ﬁlters on graphs (Hammond
et al., 2011; Defferrard et al., 2016).

2 H (l)W (l)(cid:17)

˜D− 1
2 ˜A ˜D− 1

H (l+1) = σ

.

j

2 .1 S PEC TRA L GRA PH CONVO LUT ION S

We consider spectral convolutions on graphs deﬁned as the multiplication of a signal x ∈ RN (a
scalar for every node) with a ﬁlter gθ = diag(θ) parameterized by θ ∈ RN in the Fourier domain,
i.e.:
(cid:62)
where U is the matrix of eigenvectors of the normalized graph Laplacian L = IN − D− 1
U ΛU (cid:62) , with a diagonal matrix of its eigenvalues Λ and U (cid:62)x being the graph Fourier transform
computationally expensive, as multiplication with the eigenvector matrix U is O(N 2 ). Furthermore,
of x. We can understand gθ as a function of the eigenvalues of L, i.e. gθ (Λ). Evaluating Eq. 3 is
computing the eigendecomposition of L in the ﬁrst place might be prohibitively expensive for large
graphs. To circumvent this problem, it was suggested in Hammond et al. (2011) that gθ (Λ) can be
well-approximated by a truncated expansion in terms of Chebyshev polynomials Tk (x) up to K th
order:

2 AD− 1
2 =

gθ (cid:63) x = U gθ U

(3)

x ,

(cid:48)

k Tk ( ˜Λ) ,

θ

(4)

gθ(cid:48) (Λ) ≈ K(cid:88)

k=0

gθ(cid:48) (cid:63) x ≈ K(cid:88)

λmax

Λ − IN . λmax denotes the largest eigenvalue of L. θ (cid:48) ∈ RK is now a
with a rescaled ˜Λ = 2
vector of Chebyshev coefﬁcients. The Chebyshev polynomials are recursively deﬁned as Tk (x) =
2xTk−1 (x) − Tk−2 (x), with T0 (x) = 1 and T1 (x) = x. The reader is referred to Hammond et al.
(2011) for an in-depth discussion of this approximation.
Going back to our deﬁnition of a convolution of a signal x with a ﬁlter gθ(cid:48) , we now have:

(cid:48)

k Tk ( ˜L)x ,

θ

(5)

k=0

λmax

L − IN ; as can easily be veriﬁed by noticing that (U ΛU (cid:62) )k = U ΛkU (cid:62) . Note that
with ˜L = 2
this expression is now K -localized since it is a K th -order polynomial in the Laplacian, i.e. it depends
only on nodes that are at maximum K steps away from the central node (K th -order neighborhood).
The complexity of evaluating Eq. 5 is O(|E |), i.e. linear in the number of edges. Defferrard et al.
(2016) use this K -localized convolution to deﬁne a convolutional neural network on graphs.

2 .2 LAYER -W I SE L IN EAR MODE L

A neural network model based on graph convolutions can therefore be built by stacking multiple
convolutional layers of the form of Eq. 5, each layer followed by a point-wise non-linearity. Now,
imagine we limited the layer-wise convolution operation to K = 1 (see Eq. 5), i.e. a function that is
linear w.r.t. L and therefore a linear function on the graph Laplacian spectrum.

1We provide an alternative interpretation of this propagation rule based on the Weisfeiler-Lehman algorithm
(Weisfeiler & Lehmann, 1968) in Appendix A.

2

Published as a conference paper at ICLR 2017

In this way, we can still recover a rich class of convolutional ﬁlter functions by stacking multiple
such layers, but we are not limited to the explicit parameterization given by, e.g., the Chebyshev
polynomials. We intuitively expect that such a model can alleviate the problem of overﬁtting on
local neighborhood structures for graphs with very wide node degree distributions, such as social
networks, citation networks, knowledge graphs and many other real-world graph datasets. Addition-
ally, for a ﬁxed computational budget, this layer-wise linear formulation allows us to build deeper
models, a practice that is known to improve modeling capacity on a number of domains (He et al.,
2016).
In this linear formulation of a GCN we further approximate λmax ≈ 2, as we can expect that neural
network parameters will adapt to this change in scale during training. Under these approximations
Eq. 5 simpliﬁes to:

gθ(cid:48) (cid:63) x ≈ θ

(cid:48)

0x + θ

(cid:48)

1 (L − IN ) x = θ

(cid:48)

0x − θ

(cid:48)

1D

− 1

2 AD

− 1

2 x ,

(6)

with two free parameters θ (cid:48)
0 and θ (cid:48)
1 . The ﬁlter parameters can be shared over the whole graph.
Successive application of ﬁlters of this form then effectively convolve the k th -order neighborhood of
a node, where k is the number of successive ﬁltering operations or convolutional layers in the neural
network model.
In practice, it can be beneﬁcial to constrain the number of parameters further to address overﬁtting
and to minimize the number of operations (such as matrix multiplications) per layer. This leaves us
with the following expression:

IN + D

− 1

2 AD

− 1

2

(7)

with a single parameter θ = θ (cid:48)
1 . Note that IN + D− 1
2 now has eigenvalues in
the range [0, 2]. Repeated application of this operator can therefore lead to numerical instabilities
and exploding/vanishing gradients when used in a deep neural network model. To alleviate this
problem, we introduce the following renormalization trick: IN + D− 1
2 , with

2 AD− 1
2 → ˜D− 1
2 ˜A ˜D− 1

˜A = A + IN and ˜Dii = (cid:80)

˜Aij .

j

We can generalize this deﬁnition to a signal X ∈ RN ×C with C input channels (i.e. a C -dimensional
feature vector for every node) and F ﬁlters or feature maps as follows:
− 1
− 1
(8)
where Θ ∈ RC×F is now a matrix of ﬁlter parameters and Z ∈ RN ×F is the convolved signal
matrix. This ﬁltering operation has complexity O(|E |F C ), as ˜AX can be efﬁciently implemented
as a product of a sparse matrix with a dense matrix.

Z = ˜D

2 X Θ ,

2 ˜A ˜D

3 S EM I -SU PERV I S ED NODE C LA S S I FICAT ION

Having introduced a simple, yet ﬂexible model f (X, A) for efﬁcient information propagation on
graphs, we can return to the problem of semi-supervised node classiﬁcation. As outlined in the in-
troduction, we can relax certain assumptions typically made in graph-based semi-supervised learn-
ing by conditioning our model f (X, A) both on the data X and on the adjacency matrix A of the
underlying graph structure. We expect this setting to be especially powerful in scenarios where the
adjacency matrix contains information not present in the data X , such as citation links between doc-
uments in a citation network or relations in a knowledge graph. The overall model, a multi-layer
GCN for semi-supervised learning, is schematically depicted in Figure 1.

3 .1 EXAM PL E

In the following, we consider a two-layer GCN for semi-supervised node classiﬁcation on a graph
with a symmetric adjacency matrix A (binary or weighted). We ﬁrst calculate ˆA = ˜D− 1
2 in
a pre-processing step. Our forward model then takes the simple form:

2 ˜A ˜D− 1

Z = f (X, A) = softmax

.

(9)

(cid:16)

gθ (cid:63) x ≈ θ
0 = −θ (cid:48)

(cid:17)

x ,
2 AD− 1

(cid:16)

ˆAXW (0)(cid:17)

W (1)(cid:17)

(cid:16)

ˆA ReLU

3

Published as a conference paper at ICLR 2017

(a) Graph Convolutional Network

(b) Hidden layer activations

Figure 1: Left: Schematic depiction of multi-layer Graph Convolutional Network (GCN) for semi-
supervised learning with C input channels and F feature maps in the output layer. The graph struc-
ture (edges shown as black lines) is shared over layers, labels are denoted by Yi . Right: t-SNE
(Maaten & Hinton, 2008) visualization of hidden layer activations of a two-layer GCN trained on
the Cora dataset (Sen et al., 2008) using 5% of labels. Colors denote document class.

softmax(xi ) = 1Z exp(xi ) with Z = (cid:80)

Here, W (0) ∈ RC×H is an input-to-hidden weight matrix for a hidden layer with H feature maps.
W (1) ∈ RH×F is a hidden-to-output weight matrix. The softmax activation function, deﬁned as
i exp(xi ), is applied row-wise. For semi-supervised multi-
class classiﬁcation, we then evaluate the cross-entropy error over all labeled examples:

L = − (cid:88)

F(cid:88)

Ylf ln Zlf ,

(10)

f =1

l∈YL
where YL is the set of node indices that have labels.
The neural network weights W (0) and W (1) are trained using gradient descent. In this work, we
perform batch gradient descent using the full dataset for every training iteration, which is a viable
option as long as datasets ﬁt in memory. Using a sparse representation for A, memory requirement
is O(|E |), i.e. linear in the number of edges. Stochasticity in the training process is introduced via
dropout (Srivastava et al., 2014). We leave memory-efﬁcient extensions with mini-batch stochastic
gradient descent for future work.

3 .2

IM P LEM EN TAT ION

In practice, we make use of TensorFlow (Abadi et al., 2015) for an efﬁcient GPU-based imple-
mentation2 of Eq. 9 using sparse-dense matrix multiplications. The computational complexity of
evaluating Eq. 9 is then O(|E |CH F ), i.e. linear in the number of graph edges.

4 R ELAT ED WORK

Our model draws inspiration both from the ﬁeld of graph-based semi-supervised learning and from
recent work on neural networks that operate on graphs. In what follows, we provide a brief overview
on related work in both ﬁelds.

4 .1 GRA PH -BA SED S EM I -SU PERV I S ED L EARN ING

A large number of approaches for semi-supervised learning using graph representations have been
proposed in recent years, most of which fall into two broad categories: methods that use some
form of explicit graph Laplacian regularization and graph embedding-based approaches. Prominent
examples for graph Laplacian regularization include label propagation (Zhu et al., 2003), manifold
regularization (Belkin et al., 2006) and deep semi-supervised embedding (Weston et al., 2012).

2Code to reproduce our experiments is available at https://github.com/tkipf/gcn.

4

CinputlayerX1X2X3X4FoutputlayerZ1Z2Z3Z4hiddenlayersY1Y4130201001020303020100102030Published as a conference paper at ICLR 2017

Recently, attention has shifted to models that learn graph embeddings with methods inspired by
the skip-gram model (Mikolov et al., 2013). DeepWalk (Perozzi et al., 2014) learns embeddings
via the prediction of the local neighborhood of nodes, sampled from random walks on the graph.
LINE (Tang et al., 2015) and node2vec (Grover & Leskovec, 2016) extend DeepWalk with more
sophisticated random walk or breadth-ﬁrst search schemes. For all these methods, however, a multi-
step pipeline including random walk generation and semi-supervised training is required where each
step has to be optimized separately. Planetoid (Yang et al., 2016) alleviates this by injecting label
information in the process of learning embeddings.

4 .2 N EURA L N ETWORK S ON GRA PH S

Neural networks that operate on graphs have previously been introduced in Gori et al. (2005);
Scarselli et al. (2009) as a form of recurrent neural network. Their framework requires the repeated
application of contraction maps as propagation functions until node representations reach a stable
ﬁxed point. This restriction was later alleviated in Li et al. (2016) by introducing modern practices
for recurrent neural network training to the original graph neural network framework. Duvenaud
et al. (2015) introduced a convolution-like propagation rule on graphs and methods for graph-level
classiﬁcation. Their approach requires to learn node degree-speciﬁc weight matrices which does not
scale to large graphs with wide node degree distributions. Our model instead uses a single weight
matrix per layer and deals with varying node degrees through an appropriate normalization of the
adjacency matrix (see Section 3.1).
A related approach to node classiﬁcation with a graph-based neural network was recently introduced
in Atwood & Towsley (2016). They report O(N 2 ) complexity, limiting the range of possible appli-
cations. In a different yet related model, Niepert et al. (2016) convert graphs locally into sequences
that are fed into a conventional 1D convolutional neural network, which requires the deﬁnition of a
node ordering in a pre-processing step.
Our method is based on spectral graph convolutional neural networks, introduced in Bruna et al.
(2014) and later extended by Defferrard et al. (2016) with fast localized convolutions. In contrast
to these works, we consider here the task of transductive node classiﬁcation within networks of
signiﬁcantly larger scale. We show that in this setting, a number of simpliﬁcations (see Section 2.2)
can be introduced to the original frameworks of Bruna et al. (2014) and Defferrard et al. (2016) that
improve scalability and classiﬁcation performance in large-scale networks.

5 EX PER IM EN T S

We test our model in a number of experiments: semi-supervised document classiﬁcation in cita-
tion networks, semi-supervised entity classiﬁcation in a bipartite graph extracted from a knowledge
graph, an evaluation of various graph propagation models and a run-time analysis on random graphs.

5 .1 DATA S ET S

We closely follow the experimental setup in Yang et al. (2016). Dataset statistics are summarized
in Table 1. In the citation network datasets—Citeseer, Cora and Pubmed (Sen et al., 2008)—nodes
are documents and edges are citation links. Label rate denotes the number of labeled nodes that are
used for training divided by the total number of nodes in each dataset. NELL (Carlson et al., 2010;
Yang et al., 2016) is a bipartite graph dataset extracted from a knowledge graph with 55,864 relation
nodes and 9,891 entity nodes.

Table 1: Dataset statistics, as reported in Yang et al. (2016).

Dataset

Citeseer
Cora
Pubmed
NELL

Type

Citation network
Citation network
Citation network
Knowledge graph

Nodes

3,327
2,708
19,717
65,755

Edges Classes Features Label rate

6
7
3
210

3,703
1,433
500
5,414

0.036
0.052
0.003
0.001

4,732
5,429
44,338
266,144

5

Published as a conference paper at ICLR 2017

Citation networks We consider three citation network datasets: Citeseer, Cora and Pubmed (Sen
et al., 2008). The datasets contain sparse bag-of-words feature vectors for each document and a list
of citation links between documents. We treat the citation links as (undirected) edges and construct
a binary, symmetric adjacency matrix A. Each document has a class label. For training, we only use
20 labels per class, but all feature vectors.

NELL NELL is a dataset extracted from the knowledge graph introduced in (Carlson et al., 2010).
A knowledge graph is a set of entities connected with directed, labeled edges (relations). We follow
the pre-processing scheme as described in Yang et al. (2016). We assign separate relation nodes
r1 and r2 for each entity pair (e1 , r, e2 ) as (e1 , r1 ) and (e2 , r2 ). Entity nodes are described by
sparse feature vectors. We extend the number of features in NELL by assigning a unique one-hot
representation for every relation node, effectively resulting in a 61,278-dim sparse feature vector per
node. The semi-supervised task here considers the extreme case of only a single labeled example
per class in the training set. We construct a binary, symmetric adjacency matrix from this graph by
setting entries Aij = 1, if one or more edges are present between nodes i and j .

Random graphs We simulate random graph datasets of various sizes for experiments where we
measure training time per epoch. For a dataset with N nodes we create a random graph assigning
2N edges uniformly at random. We take the identity matrix IN as input feature matrix X , thereby
implicitly taking a featureless approach where the model is only informed about the identity of each
node, speciﬁed by a unique one-hot vector. We add dummy labels Yi = 1 for every node.

5 .2 EX PER IM EN TA L S E T-U P

Unless otherwise noted, we train a two-layer GCN as described in Section 3.1 and evaluate pre-
diction accuracy on a test set of 1,000 labeled examples. We provide additional experiments using
deeper models with up to 10 layers in Appendix B. We choose the same dataset splits as in Yang et al.
(2016) with an additional validation set of 500 labeled examples for hyperparameter optimization
(dropout rate for all layers, L2 regularization factor for the ﬁrst GCN layer and number of hidden
units). We do not use the validation set labels for training.
For the citation network datasets, we optimize hyperparameters on Cora only and use the same set
of parameters for Citeseer and Pubmed. We train all models for a maximum of 200 epochs (training
iterations) using Adam (Kingma & Ba, 2015) with a learning rate of 0.01 and early stopping with a
window size of 10, i.e. we stop training if the validation loss does not decrease for 10 consecutive
epochs. We initialize weights using the initialization described in Glorot & Bengio (2010) and
accordingly (row-)normalize input feature vectors. On the random graph datasets, we use a hidden
layer size of 32 units and omit regularization (i.e. neither dropout nor L2 regularization).

5 .3 BA SE L IN E S

We compare against the same baseline methods as in Yang et al. (2016), i.e. label propagation
(LP) (Zhu et al., 2003), semi-supervised embedding (SemiEmb) (Weston et al., 2012), manifold
regularization (ManiReg) (Belkin et al., 2006) and skip-gram based graph embeddings (DeepWalk)
(Perozzi et al., 2014). We omit TSVM (Joachims, 1999), as it does not scale to the large number of
classes in one of our datasets.
We further compare against the iterative classiﬁcation algorithm (ICA) proposed in Lu & Getoor
(2003) in conjunction with two logistic regression classiﬁers, one for local node features alone and
one for relational classiﬁcation using local features and an aggregation operator as described in
Sen et al. (2008). We ﬁrst train the local classiﬁer using all labeled training set nodes and use
it to bootstrap class labels of unlabeled nodes for relational classiﬁer training. We run iterative
classiﬁcation (relational classiﬁer) with a random node ordering for 10 iterations on all unlabeled
nodes (bootstrapped using the local classiﬁer). L2 regularization parameter and aggregation operator
(count vs. prop, see Sen et al. (2008)) are chosen based on validation set performance for each dataset
separately.
Lastly, we compare against Planetoid (Yang et al., 2016), where we always choose their best-
performing model variant (transductive vs. inductive) as a baseline.

6

Published as a conference paper at ICLR 2017

6 R E SU LT S

6 .1 S EM I -SU PERV I S ED NOD E C LA S S I FICAT ION

Results are summarized in Table 2. Reported numbers denote classiﬁcation accuracy in percent. For
ICA, we report the mean accuracy of 100 runs with random node orderings. Results for all other
baseline methods are taken from the Planetoid paper (Yang et al., 2016). Planetoid* denotes the best
model for the respective dataset out of the variants presented in their paper.

Table 2: Summary of results in terms of classiﬁcation accuracy (in percent).

Method

Citeseer

Cora

Pubmed

NELL

ManiReg [3]
SemiEmb [28]
LP [32]
DeepWalk [22]
ICA [18]
Planetoid* [29]
GCN (this paper)
GCN (rand. splits)

60.1
59.6
45.3
43.2
69.1

64.7 (26s)
70.3 (7s)

67.9 ± 0.5

59.5
59.0
68.0
67.2
75.1

75.7 (13s)
81.5 (4s)

80.1 ± 0.5

70.7
71.1
63.0
65.3
73.9

77.2 (25s)
79.0 (38s)

78.9 ± 0.7

21.8
26.7
26.5
58.1
23.1

61.9 (185s)
66.0 (48s)

58.4 ± 1.7

We further report wall-clock training time in seconds until convergence (in brackets) for our method
(incl. evaluation of validation error) and for Planetoid. For the latter, we used an implementation pro-
vided by the authors3 and trained on the same hardware (with GPU) as our GCN model. We trained
and tested our model on the same dataset splits as in Yang et al. (2016) and report mean accuracy
of 100 runs with random weight initializations. We used the following sets of hyperparameters for
Citeseer, Cora and Pubmed: 0.5 (dropout rate), 5 · 10−4 (L2 regularization) and 16 (number of hid-
den units); and for NELL: 0.1 (dropout rate), 1 · 10−5 (L2 regularization) and 64 (number of hidden
units).
In addition, we report performance of our model on 10 randomly drawn dataset splits of the same
size as in Yang et al. (2016), denoted by GCN (rand. splits). Here, we report mean and standard
error of prediction accuracy on the test set split in percent.

6 .2 EVALUAT ION O F PRO PAGAT ION MODE L

We compare different variants of our proposed per-layer propagation model on the citation network
datasets. We follow the experimental set-up described in the previous section. Results are summa-
rized in Table 3. The propagation model of our original GCN model is denoted by renormalization
trick (in bold). In all other cases, the propagation model of both neural network layers is replaced
with the model speciﬁed under propagation model. Reported numbers denote mean classiﬁcation
accuracy for 100 repeated runs with random weight matrix initializations. In case of multiple vari-
ables Θi per layer, we impose L2 regularization on all weight matrices of the ﬁrst layer.

Table 3: Comparison of propagation models.

Description

Chebyshev ﬁlter (Eq. 5) K = 3

K = 2

1st -order model (Eq. 6)
Single parameter (Eq. 7)

Renormalization trick (Eq. 8)

1st -order term only
Multi-layer perceptron

(cid:80)K

Propagation model

k=0 Tk ( ˜L)X Θk
X Θ0 + D− 1
2 AD− 1
2 X Θ1
(IN + D− 1
2 AD− 1
2 )X Θ
˜D− 1
2 ˜A ˜D− 1
2 X Θ
D− 1
2 AD− 1
2 X Θ
X Θ

Citeseer Cora Pubmed

69.8
69.6

68.3
69.3
70.3

68.7
46.5

79.5
81.2

80.0
79.2
81.5

80.5
55.1

74.4
73.8

77.5
77.4
79.0

77.8
71.4

3https://github.com/kimiyoung/planetoid

7

Published as a conference paper at ICLR 2017

6 .3 TRA IN ING T IM E P ER E POCH

Here, we report results for the mean training
time per epoch (forward pass, cross-entropy
calculation, backward pass) for 100 epochs on
simulated random graphs, measured in seconds
wall-clock time. See Section 5.1 for a detailed
description of the random graph dataset used
in these experiments. We compare results on
a GPU and on a CPU-only implementation4 in
TensorFlow (Abadi et al., 2015). Figure 2 sum-
marizes the results.

7 D I SCU S S ION

7 .1 S EM I -SU PERV I S ED MOD EL

Figure 2: Wall-clock time per epoch for random
graphs. (*) indicates out-of-memory error.

In the experiments demonstrated here, our method for semi-supervised node classiﬁcation outper-
forms recent related methods by a signiﬁcant margin. Methods based on graph-Laplacian regular-
ization (Zhu et al., 2003; Belkin et al., 2006; Weston et al., 2012) are most likely limited due to their
assumption that edges encode mere similarity of nodes. Skip-gram based methods on the other hand
are limited by the fact that they are based on a multi-step pipeline which is difﬁcult to optimize.
Our proposed model can overcome both limitations, while still comparing favorably in terms of ef-
ﬁciency (measured in wall-clock time) to related methods. Propagation of feature information from
neighboring nodes in every layer improves classiﬁcation performance in comparison to methods like
ICA (Lu & Getoor, 2003), where only label information is aggregated.
We have further demonstrated that the proposed renormalized propagation model (Eq. 8) offers both
improved efﬁciency (fewer parameters and operations, such as multiplication or addition) and better
predictive performance on a number of datasets compared to a na¨ıve 1st -order model (Eq. 6) or
higher-order graph convolutional models using Chebyshev polynomials (Eq. 5).

7 .2 L IM I TAT ION S AND FU TUR E WORK

Here, we describe several limitations of our current model and outline how these might be overcome
in future work.

Memory requirement

In the current setup with full-batch gradient descent, memory requirement
grows linearly in the size of the dataset. We have shown that for large graphs that do not ﬁt in GPU
memory, training on CPU can still be a viable option. Mini-batch stochastic gradient descent can
alleviate this issue. The procedure of generating mini-batches, however, should take into account the
number of layers in the GCN model, as the K th -order neighborhood for a GCN with K layers has to
be stored in memory for an exact procedure. For very large and densely connected graph datasets,
further approximations might be necessary.

Directed edges and edge features Our framework currently does not naturally support edge fea-
tures and is limited to undirected graphs (weighted or unweighted). Results on NELL however
show that it is possible to handle both directed edges and edge features by representing the original
directed graph as an undirected bipartite graph with additional nodes that represent edges in the
original graph (see Section 5.1 for details).

Limiting assumptions Through the approximations introduced in Section 2, we implicitly assume
locality (dependence on the K th -order neighborhood for a GCN with K layers) and equal impor-
tance of self-connections vs. edges to neighboring nodes. For some datasets, however, it might be
beneﬁcial to introduce a trade-off parameter λ in the deﬁnition of ˜A:

4Hardware used: 16-core Intel R(cid:13) Xeon R(cid:13) CPU E5-2640 v3 @ 2.60GHz, GeForce R(cid:13) GTX TITAN X

˜A = A + λIN .

(11)

8

1k10k100k1M10M# Edges10-310-210-1100101Sec./epoch*GPUCPUPublished as a conference paper at ICLR 2017

This parameter now plays a similar role as the trade-off parameter between supervised and unsuper-
vised loss in the typical semi-supervised setting (see Eq. 1). Here, however, it can be learned via
gradient descent.

8 CONC LU S ION

We have introduced a novel approach for semi-supervised classiﬁcation on graph-structured data.
Our GCN model uses an efﬁcient layer-wise propagation rule that is based on a ﬁrst-order approx-
imation of spectral convolutions on graphs. Experiments on a number of network datasets suggest
that the proposed GCN model is capable of encoding both graph structure and node features in a
way useful for semi-supervised classiﬁcation. In this setting, our model outperforms several recently
proposed methods by a signiﬁcant margin, while being computationally efﬁcient.

ACKNOW L EDGM ENT S

We would like to thank Christos Louizos, Taco Cohen, Joan Bruna, Zhilin Yang, Dave Herman,
Pramod Sinha and Abdul-Saboor Sheikh for helpful discussions. This research was funded by SAP.

R E F ER ENC E S
Mart´ın Abadi et al. TensorFlow: Large-scale machine learning on heterogeneous systems, 2015.

James Atwood and Don Towsley. Diffusion-convolutional neural networks. In Advances in neural
information processing systems (NIPS), 2016.

Mikhail Belkin, Partha Niyogi, and Vikas Sindhwani. Manifold regularization: A geometric frame-
work for learning from labeled and unlabeled examples. Journal of machine learning research
(JMLR), 7(Nov):2399–2434, 2006.

Ulrik Brandes, Daniel Delling, Marco Gaertler, Robert Gorke, Martin Hoefer, Zoran Nikoloski,
and Dorothea Wagner. On modularity clustering. IEEE Transactions on Knowledge and Data
Engineering, 20(2):172–188, 2008.

Joan Bruna, Wojciech Zaremba, Arthur Szlam, and Yann LeCun. Spectral networks and locally
connected networks on graphs. In International Conference on Learning Representations (ICLR),
2014.

Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr Settles, Estevam R. Hruschka Jr, and Tom M.
Mitchell. Toward an architecture for never-ending language learning. In AAAI, volume 5, pp. 3,
2010.

Micha ¨el Defferrard, Xavier Bresson, and Pierre Vandergheynst. Convolutional neural networks on
graphs with fast localized spectral ﬁltering. In Advances in neural information processing systems
(NIPS), 2016.

Brendan L. Douglas. The Weisfeiler-Lehman method and graph isomorphism testing. arXiv preprint
arXiv:1101.5211, 2011.

David K. Duvenaud, Dougal Maclaurin, Jorge Iparraguirre, Rafael Bombarell, Timothy Hirzel, Al ´an
Aspuru-Guzik, and Ryan P. Adams. Convolutional networks on graphs for learning molecular
ﬁngerprints. In Advances in neural information processing systems (NIPS), pp. 2224–2232, 2015.

Xavier Glorot and Yoshua Bengio. Understanding the difﬁculty of training deep feedforward neural
networks. In AISTATS, volume 9, pp. 249–256, 2010.

Marco Gori, Gabriele Monfardini, and Franco Scarselli. A new model for learning in graph domains.
In Proceedings. 2005 IEEE International Joint Conference on Neural Networks., volume 2, pp.
729–734. IEEE, 2005.

Aditya Grover and Jure Leskovec. node2vec: Scalable feature learning for networks. In Proceedings
of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining.
ACM, 2016.

9

Published as a conference paper at ICLR 2017

David K. Hammond, Pierre Vandergheynst, and R ´emi Gribonval. Wavelets on graphs via spectral
graph theory. Applied and Computational Harmonic Analysis, 30(2):129–150, 2011.

Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recog-
nition. In IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2016.

Thorsten Joachims. Transductive inference for text classiﬁcation using support vector machines. In
International Conference on Machine Learning (ICML), volume 99, pp. 200–209, 1999.

Diederik P. Kingma and Jimmy Lei Ba. Adam: A method for stochastic optimization. In Interna-
tional Conference on Learning Representations (ICLR), 2015.

Yujia Li, Daniel Tarlow, Marc Brockschmidt, and Richard Zemel. Gated graph sequence neural
networks. In International Conference on Learning Representations (ICLR), 2016.

Qing Lu and Lise Getoor. Link-based classiﬁcation. In International Conference on Machine Learn-
ing (ICML), volume 3, pp. 496–503, 2003.

Laurens van der Maaten and Geoffrey Hinton. Visualizing data using t-sne. Journal of Machine
Learning Research (JMLR), 9(Nov):2579–2605, 2008.

Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S. Corrado, and Jeff Dean. Distributed repre-
sentations of words and phrases and their compositionality. In Advances in neural information
processing systems (NIPS), pp. 3111–3119, 2013.

Mathias Niepert, Mohamed Ahmed, and Konstantin Kutzkov. Learning convolutional neural net-
works for graphs. In International Conference on Machine Learning (ICML), 2016.

Bryan Perozzi, Rami Al-Rfou, and Steven Skiena. Deepwalk: Online learning of social repre-
sentations.
In Proceedings of the 20th ACM SIGKDD international conference on Knowledge
discovery and data mining, pp. 701–710. ACM, 2014.

Franco Scarselli, Marco Gori, Ah Chung Tsoi, Markus Hagenbuchner, and Gabriele Monfardini.
The graph neural network model. IEEE Transactions on Neural Networks, 20(1):61–80, 2009.

Prithviraj Sen, Galileo Namata, Mustafa Bilgic, Lise Getoor, Brian Galligher, and Tina Eliassi-Rad.
Collective classiﬁcation in network data. AI magazine, 29(3):93, 2008.

Nitish Srivastava, Geoffrey E. Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov.
Dropout: a simple way to prevent neural networks from overﬁtting. Journal of Machine Learning
Research (JMLR), 15(1):1929–1958, 2014.

Jian Tang, Meng Qu, Mingzhe Wang, Ming Zhang, Jun Yan, and Qiaozhu Mei. Line: Large-scale
information network embedding. In Proceedings of the 24th International Conference on World
Wide Web, pp. 1067–1077. ACM, 2015.

Boris Weisfeiler and A. A. Lehmann. A reduction of a graph to a canonical form and an algebra
arising during this reduction. Nauchno-Technicheskaya Informatsia, 2(9):12–16, 1968.

Jason Weston, Fr ´ed ´eric Ratle, Hossein Mobahi, and Ronan Collobert. Deep learning via semi-
supervised embedding. In Neural Networks: Tricks of the Trade, pp. 639–655. Springer, 2012.

Zhilin Yang, William Cohen, and Ruslan Salakhutdinov. Revisiting semi-supervised learning with
graph embeddings. In International Conference on Machine Learning (ICML), 2016.

Wayne W. Zachary. An information ﬂow model for conﬂict and ﬁssion in small groups. Journal of
anthropological research, pp. 452–473, 1977.

Dengyong Zhou, Olivier Bousquet, Thomas Navin Lal, Jason Weston, and Bernhard Sch ¨olkopf.
Learning with local and global consistency. In Advances in neural information processing systems
(NIPS), volume 16, pp. 321–328, 2004.

Xiaojin Zhu, Zoubin Ghahramani, and John Lafferty. Semi-supervised learning using gaussian ﬁelds
and harmonic functions. In International Conference on Machine Learning (ICML), volume 3,
pp. 912–919, 2003.

10

Published as a conference paper at ICLR 2017

A R ELAT ION TO W E I S FE I LER -L EHMAN A LGOR I THM

A neural network model for graph-structured data should ideally be able to learn representations of
nodes in a graph, taking both the graph structure and feature description of nodes into account. A
well-studied framework for the unique assignment of node labels given a graph and (optionally) dis-
crete initial node labels is provided by the 1-dim Weisfeiler-Lehman (WL-1) algorithm (Weisfeiler
& Lehmann, 1968):

Algorithm 1: WL-1 algorithm (Weisfeiler & Lehmann, 1968)

Input: Initial node coloring (h(0)
Output: Final node coloring (h(T )
t ← 0;

1 , h(0)
, h(T )
1
2

2 , ..., h(0)
N )
, ..., h(T )
N )

repeat
for vi ∈ V do

h(t+1)

i ← hash
t ← t + 1;

(cid:16)(cid:80)

(cid:17)

;

j∈Ni h(t)
j

i

until stable node coloring is reached;
denotes the coloring (label assignment) of node vi (at iteration t) and Ni is its set of
Here, h(t)
neighboring node indices (irrespective of whether the graph includes self-connections for every node
or not). hash(·) is a hash function. For an in-depth mathematical discussion of the WL-1 algorithm
see, e.g., Douglas (2011).
We can replace the hash function in Algorithm 1 with a neural network layer-like differentiable
function with trainable parameters as follows:

 (cid:88)

j∈Ni

 ,

h(l+1)
i

= σ

1

cij

h(l)
j W (l)

(12)

i

where cij is an appropriately chosen normalization constant for the edge (vi , vj ). Further, we can
By choosing cij = (cid:112)didj , where di = |Ni | denotes the degree of node vi , we recover the propaga-
take h(l)
layer-speciﬁc weight matrix and σ(·) denotes a differentiable, non-linear activation function.
now to be a vector of activations of node i in the l th neural network layer. W (l) is a
tion rule of our Graph Convolutional Network (GCN) model in vector form (see Eq. 2)5 .
This—loosely speaking—allows us to interpret our GCN model as a differentiable and parameter-
ized generalization of the 1-dim Weisfeiler-Lehman algorithm on graphs.

From the analogy with the Weisfeiler-Lehman algorithm, we can understand that even an untrained
GCN model with random weights can serve as a powerful feature extractor for nodes in a graph. As
an example, consider the following 3-layer GCN model:

A .1 NOD E EMB EDD ING S W I TH RANDOM W E IGH T S
ˆAXW (0)(cid:17)

W (1)(cid:17)

W (2)(cid:17)

,

(13)

Z = tanh

ˆA tanh

ˆA tanh

(cid:16)

(cid:16)

(cid:16)

with weight matrices W (l) initialized at random using the initialization described in Glorot & Bengio
(2010). ˆA, X and Z are deﬁned as in Section 3.1.
We apply this model on Zachary’s karate club network (Zachary, 1977). This graph contains 34
nodes, connected by 154 (undirected and unweighted) edges. Every node is labeled by one of
four classes, obtained via modularity-based clustering (Brandes et al., 2008). See Figure 3a for an
illustration.

5Note that we here implicitly assume that self-connections have already been added to every node in the
graph (for a clutter-free notation).

11

Published as a conference paper at ICLR 2017

(a) Karate club network

(b) Random weight embedding

Figure 3: Left: Zachary’s karate club network (Zachary, 1977), colors denote communities obtained
via modularity-based clustering (Brandes et al., 2008). Right: Embeddings obtained from an un-
trained 3-layer GCN model (Eq. 13) with random weights applied to the karate club network. Best
viewed on a computer screen.

We take a featureless approach by setting X = IN , where IN is the N by N identity matrix. N is
the number of nodes in the graph. Note that nodes are randomly ordered (i.e. ordering contains no
information). Furthermore, we choose a hidden layer dimensionality6 of 4 and a two-dimensional
output (so that the output can immediately be visualized in a 2-dim plot).
Figure 3b shows a representative example of node embeddings (outputs Z ) obtained from an un-
trained GCN model applied to the karate club network. These results are comparable to embeddings
obtained from DeepWalk (Perozzi et al., 2014), which uses a more expensive unsupervised training
procedure.

A .2 S EM I -SU PERV I S ED NOD E EMB EDD ING S

On this simple example of a GCN applied to the karate club network it is interesting to observe how
embeddings react during training on a semi-supervised classiﬁcation task. Such a visualization (see
Figure 4) provides insights into how the GCN model can make use of the graph structure (and of
features extracted from the graph structure at later layers) to learn embeddings that are useful for a
classiﬁcation task.
We consider the following semi-supervised learning setup: we add a softmax layer on top of our
model (Eq. 13) and train using only a single labeled example per class (i.e. a total number of 4 labeled
nodes). We train for 300 training iterations using Adam (Kingma & Ba, 2015) with a learning rate
of 0.01 on a cross-entropy loss.
Figure 4 shows the evolution of node embeddings over a number of training iterations. The model
succeeds in linearly separating the communities based on minimal supervision and the graph struc-
ture alone. A video of the full training process can be found on our website7 .

6We originally experimented with a hidden layer dimensionality of 2 (i.e. same as output layer), but observed
that a dimensionality of 4 resulted in less frequent saturation of tanh(·) units and therefore visually more
pleasing results.

7http://tkipf.github.io/graph-convolutional-networks/

12

Published as a conference paper at ICLR 2017

(a) Iteration 25

(b) Iteration 50

(c) Iteration 75

(d) Iteration 100

(e) Iteration 200

(f) Iteration 300

Figure 4: Evolution of karate club network node embeddings obtained from a GCN model after a
number of semi-supervised training iterations. Colors denote class. Nodes of which labels were
provided during training (one per class) are highlighted (grey outline). Grey links between nodes
denote graph edges. Best viewed on a computer screen.

13

Published as a conference paper at ICLR 2017

B EX PER IM EN T S ON MODE L D E P TH

In these experiments, we investigate the inﬂuence of model depth (number of layers) on classiﬁcation
performance. We report results on a 5-fold cross-validation experiment on the Cora, Citeseer and
Pubmed datasets (Sen et al., 2008) using all labels. In addition to the standard GCN model (Eq. 2),
we report results on a model variant where we use residual connections (He et al., 2016) between
hidden layers to facilitate training of deeper models by enabling the model to carry over information
from the previous layer’s input:

(cid:16)

2 H (l)W (l)(cid:17)

H (l+1) = σ

˜D− 1
2 ˜A ˜D− 1

+ H (l) .

(14)

On each cross-validation split, we train for 400 epochs (without early stopping) using the Adam
follows: 0.5 (dropout rate, ﬁrst and last layer), 5 · 10−4 (L2 regularization, ﬁrst layer), 16 (number
optimizer (Kingma & Ba, 2015) with a learning rate of 0.01. Other hyperparameters are chosen as
of units for each hidden layer) and 0.01 (learning rate). Results are summarized in Figure 5.

Figure 5: Inﬂuence of model depth (number of layers) on classiﬁcation performance. Markers
denote mean classiﬁcation accuracy (training vs. testing) for 5-fold cross-validation. Shaded areas
denote standard error. We show results both for a standard GCN model (dashed lines) and a model
with added residual connections (He et al., 2016) between hidden layers (solid lines).

For the datasets considered here, best results are obtained with a 2- or 3-layer model. We observe
that for models deeper than 7 layers, training without the use of residual connections can become
difﬁcult, as the effective context size for each node increases by the size of its K th -order neighbor-
hood (for a model with K layers) with each additional layer. Furthermore, overﬁtting can become
an issue as the number of parameters increases with model depth.

14

12345678910Number of layers0.500.550.600.650.700.750.800.850.90AccuracyCiteseerTrainTrain (Residual)TestTest (Residual)12345678910Number of layers0.550.600.650.700.750.800.850.900.95AccuracyCoraTrainTrain (Residual)TestTest (Residual)12345678910Number of layers0.760.780.800.820.840.860.88AccuracyPubmedTrainTrain (Residual)TestTest (Residual)